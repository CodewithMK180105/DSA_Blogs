[
    {
      "title": "3 Sum",
      "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.",
      "slug": "3sum",
      "date": "27-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727711522/three_sum_x6y88h.png",
      "content": "## Problem: 3Sum (LeetCode)\n\nThe \"3Sum\" problem (LeetCode #15) asks you to find all unique triplets in the array that sum up to zero. The solution should avoid duplicate triplets, and the array can contain both positive and negative numbers.\n\n## Problem Statement:\nGiven an integer array nums, return all the unique triplets [nums[i], nums[j], nums[k]] such that:\n\n- i, j, and k are distinct indices.\n- nums[i] + nums[j] + nums[k] == 0.\n\n## Solution Overview:\nTo solve this problem efficiently, we use a sorted array and a two-pointer approach. Sorting helps in skipping duplicates and managing the two-pointer technique effectively.\n\n## Approach:\n\n**1. Sort the array:** Sorting helps us handle duplicates and efficiently use two pointers to find the triplets.\n\n**2. Iterate through the array:** We loop through each element nums[i] and for each element, we apply the two-pointer technique to find two other elements that sum to -nums[i].\n\n**3. Use two pointers:** After fixing nums[i], use two pointers: one starting from the next element j = i + 1 and the other from the end k = nums.size() - 1. Move the pointers inward based on the sum of the elements.\n\n**4. Skip duplicates:** After finding a valid triplet, we skip any duplicate elements to ensure we only include unique triplets.\n\n## Code Explanation:\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n\n        vector<vector<int>> result; // To store the resulting triplets\n\n        sort(nums.begin(), nums.end());  // Sort the array to apply two-pointer approach\n\n        for(int i = 0; i < nums.size() - 2; i++) {\n\n            // Skip duplicate values for the first element\n            if(i > 0 && nums[i] == nums[i - 1]) continue;\n\n            int j = i + 1, k = nums.size() - 1;  // Two-pointer initialization\n            while(j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n\n                // If the sum is zero, we found a valid triplet\n                if(sum == 0) {\n                    result.push_back({nums[i], nums[j], nums[k]});\n\n                    // Skip duplicates for the second and third elements\n                    while(j < k && nums[j] == nums[j + 1]) j++;\n                    while(j < k && nums[k] == nums[k - 1]) k--;\n\n                    // Move both pointers inward after finding a triplet\n                    j++;\n                    k--;\n                }\n                // If the sum is less than zero, move the left pointer right to increase the sum\n                else if(sum < 0) {\n                    j++;\n                }\n                // If the sum is greater than zero, move the right pointer left to decrease the sum\n                else {\n                    k--;\n                }\n            }\n        }\n        return result;  // Return the list of triplets\n    }\n};\n```\n\n## Dry Run:\nLet's walk through an example with nums = [-1, 0, 1, 2, -1, -4].\n\n**Step 1:**\n\nSort the array: [-4, -1, -1, 0, 1, 2]\n\n**Step 2:**\n\nStart with i = 0, nums[i] = -4.\n\nSet j = 1 and k = 5.\n\nThe sum is -4 + (-1) + 2 = -3. This is less than zero, so move j to 2.\n\nThe sum is -4 + (-1) + 2 = -3. Move j to 3.\n\nThe sum is -4 + 0 + 2 = -2. Move j to 4.\n\nThe sum is -4 + 1 + 2 = -1. Move j to 5. No triplet found.\n\n**Step 3:**\n\nMove to i = 1, nums[i] = -1.\n\nSet j = 2 and k = 5.\n\nThe sum is -1 + (-1) + 2 = 0. Triplet found: [-1, -1, 2].\n\nSkip duplicates for j and k and move inward. j = 3, k = 4.\n\nThe sum is -1 + 0 + 1 = 0. Triplet found: [-1, 0, 1].\n\n**Step 4:**\n\nContinue iterating, skipping duplicates and updating pointers. The result will include unique triplets: [-1, -1, 2] and [-1, 0, 1].\n\n## Time Complexity:\n\n**Time Complexity:** O(n²)\n\nSorting takes O(n log n), and we have a nested loop where two pointers traverse the array, resulting in an overall time complexity of O(n²).\n\n**Space Complexity:** O(n)\n\nWe use a vector to store the result, and sorting the array requires additional space.\n\n## Conclusion:\nThis solution efficiently finds all unique triplets that sum up to zero using sorting and the two-pointer approach. By skipping duplicates and moving pointers strategically, we reduce the time complexity to O(n²) compared to a brute-force solution, making it suitable for larger inputs."
    },
    {
      "title": "Add Two Numbers",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
      "slug": "add-two-numbers",
      "date": "24-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727711953/add-two-numbers_b4bq3a.png",
      "content": "## Adding Two Numbers Represented by Linked Lists\n\nIn this post, we'll discuss how to add two numbers represented by linked lists in reverse order. Each linked list node contains a single digit, and the digits are stored in reverse order, making it easier to perform addition similar to how we do it manually.\n\n## Problem Description\n\nGiven two non-empty linked lists representing two non-negative integers, where the digits are stored in reverse order, we need to add the two numbers and return the sum as a linked list. Each node in the linked list represents a single digit.\n\n## Example\n\nFor instance, the linked list 2 -> 4 -> 3 represents the number 342, and 5 -> 6 -> 4 represents 465. The expected output is the linked list 7 -> 0 -> 8, which represents the number 807.\n\n## Code Implementation\nHere’s the C++ code that implements this logic:\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* head = new ListNode(); // Dummy head to simplify the result construction\n        ListNode* temp = head; // Pointer to track the current node in the result\n        int carry = 0; // Initialize carry to zero\n\n        // Loop until both lists are exhausted and there's no carry left\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\n            int sum = carry; // Start with carry for this iteration\n            \n            // Add value from l1 if it's available\n            if (l1 != nullptr) {\n                sum += l1->val;\n                l1 = l1->next; // Move to the next node in l1\n            }\n            \n            // Add value from l2 if it's available\n            if (l2 != nullptr) {\n                sum += l2->val;\n                l2 = l2->next; // Move to the next node in l2\n            }\n            \n            carry = sum / 10; // Update carry for next iteration\n            temp->next = new ListNode(sum % 10); // Create a new node with the current digit\n            temp = temp->next; // Move to the new node\n        }\n\n        return head->next; // Return the next of dummy head\n    }\n};\n```\n\n## Code Explanation\n**1. ListNode Structure:** The ListNode struct defines the nodes of the linked list. Each node contains an integer value (val) and a pointer to the next node (next).\n\n**2. Dummy Head Node:** A dummy head node is created to facilitate the construction of the result linked list. This simplifies the process since we don’t need to handle special cases for the head node separately.\n\n**3. Carry Variable:** We maintain a carry variable to store any overflow that results from the addition of two digits.\n\n**4. Main Loop:** The main loop continues until both linked lists are fully processed and there is no carry left:\n\n   - The sum variable is initialized with the current value of carry.\n\n   - We check if l1 and l2 have remaining nodes, adding their values to sum if they do.\n\n   - The carry is updated based on the total sum, and a new node is created with the current digit (sum % 10), which is then added to the result list.\n\n**5. Return Statement:** Finally, we return head->next to skip the dummy node and return the actual result.\n\n## Complexity Analysis\n\n**Time Complexity:** O(max(m,n)), where m and n are the lengths of the two linked lists. We may need to traverse both lists completely.\n\n**Space Complexity:** O(max(m,n)) for the resulting linked list, which can be as long as the longer input list plus one for the carry.\n\n## Dry Run Example\nLet's perform a dry run of the function with the following input:\n\n**Input:**\n\nl1: 2 -> 4 -> 3 (represents the number 342)\n\nl2: 5 -> 6 -> 4 (represents the number 465)\n\n## Iteration Breakdown\n\n**Initialization:**\n\ncarry = 0\n\nhead points to a new dummy node.\n\n**First Iteration:**\n\nsum = 0 + 2 + 5 = 7\n\ncarry = 0\n\nResult: 7 (temp points to the new node with value 7)\n\n**Second Iteration:**\n\nsum = 0 + 4 + 6 = 10\n\ncarry = 1\n\nResult: 7 -> 0 (temp points to the new node with value 0)\n\n**Third Iteration:**\n\nsum = 1 + 3 + 4 = 8\n\ncarry = 0\n\nResult: 7 -> 0 -> 8 (temp points to the new node with value 8)\n\n**End of Iterations:**\n\nBoth lists are exhausted, and there is no carry left.\n\n## Final Output\nThe final output linked list represents the number 807:\n\n**Output:** 7 -> 0 -> 8\n\n## Conclusion\nIn this blog post, we examined the problem of adding two numbers represented by linked lists and discussed a solution implemented in C++. We explored the code step-by-step, analyzed its complexity, and performed a dry run to visualize how the algorithm works. This solution efficiently handles the addition of numbers using the properties of linked lists. If you have any questions or comments, feel free to reach out!"
    },
    {
      "title": "Container with most Water",
      "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.",
      "slug": "container-with-most-water",
      "date": "25-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727706692/container-with-most-water_sbqlm3.png",
      "content": "## Problem: Container With Most Water (LeetCode)\n\nThe \"Container With Most Water\" problem (LeetCode #11) asks you to find two lines from a given list of heights that together with the x-axis form a container, such that the container holds the most water. The height of the container is determined by the shorter of the two lines.\n\n## Problem Statement:\n\nGiven an array `height` of positive integers where each integer represents the height of a vertical line at that index, you need to determine the maximum area of water a container can store.\n\n## Solution Overview:\n\nThe key idea is to use a two-pointer approach. We start with two pointers: one at the beginning (`left`) and the other at the end (`right`) of the array. The area between the two lines is calculated as:\n\n- **Width** = distance between the two pointers (`right - left`).\n- **Height** = the smaller of the two heights `height[left]` and `height[right]`.\n\nThe area will be the product of these two values. We then move the pointer corresponding to the shorter line inward to try to find a larger area.\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left = 0, right = height.size() - 1;\n        int max_area = 0;\n        while (left < right) {\n            int area = 0;\n            if (height[left] < height[right]) {\n                area = height[left] * (right - left);\n                left++;\n            }\n            else {\n                area = height[right] * (right - left);\n                right--;\n            }\n            max_area = max(area, max_area);\n        }\n        return max_area;\n    }\n};\n```\n\n## Dry Run:\n\nLet’s walk through the solution step by step using an example:\n\nExample: `height = [1, 8, 6, 2, 5, 4, 8, 3, 7]`\n\n**Initialization:**\n\n- `left = 0`, `right = 8` (pointing to the first and last element).\n- `max_area = 0`.\n\n**First Iteration:**\n\n- `height[left] = 1`, `height[right] = 7`.\n- Area = `min(1, 7) * (8 - 0) = 1 * 8 = 8`.\n- `max_area = 8`.\n- Since `height[left]` is smaller, move `left` to 1.\n\n**Second Iteration:**\n\n- `height[left] = 8`, `height[right] = 7`.\n- Area = `min(8, 7) * (8 - 1) = 7 * 7 = 49`.\n- `max_area = 49`.\n- Since `height[right]` is smaller, move `right` to 7.\n\n**Third Iteration:**\n\n- `height[left] = 8`, `height[right] = 3`.\n- Area = `min(8, 3) * (7 - 1) = 3 * 6 = 18`.\n- `max_area = 49`.\n- Move `right` to 6 since `height[right]` is smaller.\n\n**Fourth Iteration:**\n\n- `height[left] = 8`, `height[right] = 8`\n- Area = `min(8, 8) * (6 - 1) = 8 * 5 = 40`.\n- `max_area = 49`.\n- Move `right` to 5.\n\nThe process continues until `left` meets `right`, updating the `max_area` at each step.\n\n## Complexity Analysis:\n\n- **Time Complexity:** `O(n)` - We only pass through the list once using two pointers.\n- **Space Complexity:** `O(1)` - No additional space is used apart from a few variables.\n\n## Explanation:\n\nBy always moving the pointer corresponding to the smaller height, we maximize the possibility of finding a larger area. This is because the area is constrained by the shorter height, and by moving one pointer, we hope to encounter taller lines while maintaining a reasonable width.\n\n## Conclusion:\n\nThis solution efficiently finds the maximum area container using a two-pointer technique. The two-pointer approach reduces the time complexity from `O(n²)` (in a brute force solution) to `O(n)`, making it optimal for large input sizes."
    },
    {
      "title": "Maximum Subarray",
      "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
      "slug": "maximum-subarray",
      "date": "29-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727710914/maximum-subarray_azcztp.png",
      "content": "## Maximum Subarray Problem\nIn this post, we'll explore the solution to the Maximum Subarray Problem, which involves finding the contiguous subarray within a one-dimensional array of numbers that has the largest sum. This is a common problem in coding interviews and algorithm challenges.\n\n## Problem Description\nGiven an integer array `nums`, our task is to find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n## Example\nFor example, given the array `[-2,1,-3,4,-1,2,1,-5,4]`, the maximum sum of the contiguous subarray is `6`, derived from the subarray `[4,-1,2,1]`.\n\n## Code Implementation\nHere’s the C++ code that implements this logic using Kadane's Algorithm:\n\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxSum = INT_MIN; // Initialize maxSum to the smallest possible integer\n        int currSum = 0; // Initialize current sum to zero\n        \n        // Iterate through the array\n        for (int i = 0; i < nums.size(); i++) {\n            currSum += nums[i]; // Add the current element to currSum\n            maxSum = max(currSum, maxSum); // Update maxSum if currSum is greater\n            \n            // If currSum becomes negative, reset it to zero\n            if (currSum < 0) {\n                currSum = 0; \n            }\n        }\n        return maxSum; // Return the maximum sum found\n    }\n};\n```\n\n## Code Explanation\n\n**Initialization:**\n\n- `maxSum` is initialized to the smallest possible integer value to ensure that any sum will be larger than this initial value.\n\n- `currSum` keeps track of the sum of the current subarray.\n\n**Iteration:**\n\n- We loop through each element of the `nums` array, adding each element to `currSum`.\n\n- After updating `currSum`, we check if it exceeds `maxSum` and update `maxSum` accordingly.\n\n**Resetting `currSum`:**\n\n- If `currSum` becomes negative, we reset it to zero. This means that starting a new subarray from the next element may yield a higher sum.\n\n**Return Value:**\n\n- Finally, we return `maxSum`, which contains the largest sum of all contiguous subarrays.\n\n## Complexity Analysis\n\n- **Time Complexity:** `O(n)`, where `n` is the number of elements in the `nums` array. We traverse the array once.\n\n- **Space Complexity:** `O(1)`. We use a constant amount of space for the variables `maxSum` and `currSum`.\n\n## Dry Run Example\n\nLet's perform a dry run of the function with the following input:\n\n**Input:**\n\n`nums`: `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`\n\n## Iteration Breakdown\n\n**Initialization:**\n\n- `maxSum = INT_MIN`\n\n- `currSum = 0`\n\n**First Iteration (i=0):**\n\n- `currSum += -2` → `currSum = -2`\n\n- `maxSum = max(-2, INT_MIN)` → `maxSum = -2`\n\n- Since `currSum < 0`, reset `currSum` to 0.\n\n**Second Iteration (i=1):**\n\n- `currSum += 1` → `currSum = 1`\n\n- `maxSum = max(1, -2)` → `maxSum = 1`\n\n**Third Iteration (i=2):**\n\n- `currSum += -3` → `currSum = -2`\n\n- `maxSum = max(-2, 1)` → `maxSum = 1`\n\n- Reset `currSum` to 0.\n\n**Fourth Iteration (i=3):**\n\n- `currSum += 4` → `currSum = 4`\n\n- `maxSum = max(4, 1)` → `maxSum = 4`\n\n**Fifth Iteration (i=4):**\n\n- `currSum += -1` → `currSum = 3`\n\n- `maxSum = max(3, 4)` → `maxSum = 4`\n\n**Sixth Iteration (i=5):**\n\n- `currSum += 2` → `currSum = 5`\n\n- `maxSum = max(5, 4)` → `maxSum = 5`\n\n**Seventh Iteration (i=6):**\n\n- `currSum += 1` → `currSum = 6`\n\n- `maxSum = max(6, 5)` → `maxSum = 6`\n\n**Eighth Iteration (i=7):**\n\n- `currSum += -5` → `currSum = 1`\n\n- `maxSum = max(1, 6)` → `maxSum = 6`\n\n**Ninth Iteration (i=8):**\n\n- `currSum += 4` → `currSum = 5`\n\n- `maxSum = max(5, 6)` → `maxSum = 6`\n\n## Final Output\n\nThe final output is `6`, which is the maximum sum of the contiguous subarray `[4, -1, 2, 1]`.\n\n## Conclusion\n\nIn this post, we examined the Maximum Subarray Problem and explored an efficient solution using Kadane's Algorithm. We discussed the code implementation, analyzed its complexity, and performed a dry run to illustrate how the algorithm works. This approach effectively finds the maximum sum of contiguous subarrays in linear time."
    },
    {
      "title": "Median of Two Sorted Arrays",
      "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).",
      "slug": "median-of-two-sorted-arrays",
      "date": "26-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727707571/median-of-two-sorted-arrays_hjkegh.png",
      "content": "## Median of Two Sorted Arrays\n\nIn this post, we'll tackle the problem of finding the Median of Two Sorted Arrays. This is a classic problem that often appears in coding interviews and requires a good understanding of binary search.\n\n## Problem Description\n\nGiven two sorted arrays, `nums1` and `nums2`, our goal is to find the median of the two sorted arrays. The median is the middle element in a sorted array, or the average of the two middle elements if the array has an even number of elements.\n\n## Example\n\nFor instance, if we have:\n\n`nums1 = [1, 3]`\n\n`nums2 = [2]`\n\nThe median is `2.0`.\n\nFor the arrays:\n\n`nums1 = [1, 2]`\n\n`nums2 = [3, 4]`\n\nThe median is `(2 + 3) / 2 = 2.5`.\n\n## Code Implementation\n\nHere’s the C++ code that implements this logic using binary search:\n\n```cpp\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Ensure nums1 is the smaller array\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size();\n        int n = nums2.size();\n        int low = 0;\n        int high = m;\n\n        while (low <= high) {\n            int partitionX = (low + high) / 2; // Partition for nums1\n            int partitionY = (n + m + 1) / 2 - partitionX; // Partition for nums2\n\n            // Handling edge cases for partitions\n            int maxLeftX = partitionX == 0 ? INT_MIN : nums1[partitionX - 1];\n            int minRightX = partitionX == m ? INT_MAX : nums1[partitionX];\n\n            int maxLeftY = partitionY == 0 ? INT_MIN : nums2[partitionY - 1];\n            int minRightY = partitionY == n ? INT_MAX : nums2[partitionY];\n\n            // Check if we have partitioned correctly\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                // Even combined length\n                if ((m + n) % 2 == 0) {\n                    return (double)(max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2.0;\n                } else { // Odd combined length\n                    return (double)max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) { // Move towards the left in nums1\n                high = partitionX - 1;\n            } else { // Move towards the right in nums1\n                low = partitionX + 1;\n            }\n        }\n        throw invalid_argument(\"Input arrays are not sorted.\");\n    }\n};\n```\n\n### Code Explanation\n\n**1. Ensuring Array Order:**\n\nWe first check if `nums1` is larger than `nums2`. If so, we swap them to ensure that `nums1` is the smaller array. This simplifies the binary search.\n\n**2. Initialization:**\n\nWe get the sizes of both arrays, `m` and `n`, and initialize our binary search bounds: `low` and `high`.\n\n**3. Binary Search:**\n\nWe perform a binary search on `nums1` to find the correct partition such that the left side of the partition contains elements less than or equal to the right side.\n\n**4. Partition Calculation:**\n\nFor each partition in `nums1`, we calculate the corresponding partition in `nums2`. We also find the maximum and minimum values on both sides of the partitions.\n\n**5. Checking Conditions:**\n\nIf the maximum of the left side of `nums1` is less than or equal to the minimum of the right side of `nums2`, and vice versa, we have found the correct partitions.\n\nDepending on whether the total length of the combined arrays is odd or even, we compute the median.\n\n**6. Adjusting Partitions:**\n\nIf the partition is not correct, we adjust our search range by moving either left or right based on the comparison of the maximum and minimum values.\n\n**7. Return Value:**\n\nFinally, we return the computed median.\n\n## Complexity Analysis\n\n- **Time Complexity:** `O(log(min(m,n)))`, where `m` and `n` are the sizes of the two arrays. We perform a binary search on the smaller array.\n\n- **Space Complexity:** `O(1)`. We use a constant amount of extra space for variables.\n\n## Dry Run Example\n\nLet’s perform a dry run of the function with the following input:\n\n**Input:**\n\n`nums1`: `[1, 3]`\n\n`nums2`: `[2]`\n\n## Iteration Breakdown\n\n**Initialization:**\n\n- `m = 2`, `n = 1`, `low = 0`, `high = 2`.\n\n**First Iteration:**\n\n- `partitionX = (0 + 2) / 2 = 1`\n\n- `partitionY = (1 + 2 + 1) / 2 - 1 = 1`\n\n**Partitions:**\n\n- `maxLeftX = nums1[0] = 1`\n\n- `minRightX = nums1[1] = 3`\n\n- `maxLeftY = nums2[0] = 2`\n\n- `minRightY = INT_MAX`\n\nCheck: `1 <= INT_MAX` and `2 <= 3` (True).\n\n**Median Calculation:**\n\nCombined length is odd → return `max(1, 2) = 2`.\n\n**Final Output**\n\nThe final output is `2.0`, which is the median of the two sorted arrays.\n\n## Conclusion\n\nIn this post, we examined how to find the median of two sorted arrays using an efficient binary search approach. We discussed the code implementation, analyzed its complexity, and performed a dry run to illustrate the algorithm's operation. This approach provides a way to find the median in logarithmic time, making it optimal for large datasets."
    },
    {
      "title": "Merge Two Sorted Lists",
      "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
      "slug": "merge-two-sorted-lists",
      "date": "29-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727709243/merge-two-sorted-lists_vakzyv.png",
      "content": "## Merge Two Sorted Linked Lists\n\nIn this post, we will explore how to merge two sorted linked lists into one sorted linked list. This problem is a common interview question that helps test your understanding of linked list manipulation.\n\n## Problem Description\n\nGiven two sorted linked lists, `list1` and `list2`, the task is to merge them into a new sorted linked list. The resulting list should be made by splicing together the nodes of the first two lists.\n\n## Example\n\nConsider the following two sorted linked lists:\n\n`list1`: `1 → 2 → 4`\n\n`list2`: `1 → 3 → 4`\n\nThe merged linked list should look like:\n\n`1 → 1 → 2 → 3 → 4 → 4`\n\n## Code Implementation\n\nHere’s the C++ code that implements this merging logic:\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n **/\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* ptr = new ListNode(); // Temporary node to hold the merged list\n        ListNode* temp = ptr; // Pointer to track the last node of the merged list\n\n        // Traverse both lists and append the smaller node to the merged list\n        while (list1 != NULL && list2 != NULL) {\n            if (list1->val < list2->val) {\n                temp->next = list1; // Append list1's node\n                list1 = list1->next; // Move to the next node in list1\n            } else {\n                temp->next = list2; // Append list2's node\n                list2 = list2->next; // Move to the next node in list2\n            }\n            temp = temp->next; // Move to the last node of the merged list\n        }\n\n        // If there are remaining nodes in list1, append them\n        while (list1 != NULL) {\n            temp->next = list1;\n            list1 = list1->next;\n            temp = temp->next;\n        }\n\n        // If there are remaining nodes in list2, append them\n        while (list2 != NULL) {\n            temp->next = list2;\n            list2 = list2->next;\n            temp = temp->next;\n        }\n\n        return ptr->next; // Return the merged list, skipping the temporary head\n    }\n};\n```\n\n## Code Explanation\n\n**1. Node Definition:**\n\nThe `ListNode` structure is defined, which has an integer value (`val`) and a pointer to the next node (`next`).\n\n**2. Temporary Node:**\n\nWe create a temporary head node `ptr` to simplify the merging process. This node will help in constructing the new merged list.\n\n**3. Merging Process:**\n\nWe loop through both linked lists (`list1` and `list2`) until we reach the end of one of them. During each iteration, we compare the values of the nodes in both lists.\n\nThe smaller value node is appended to the merged list, and we move the corresponding pointer to its next node.\n\n**4. Appending Remaining Nodes:**\n\nOnce one of the lists is fully traversed, we append the remaining nodes from the other list. This is done using two separate while loops, one for each list.\n\n**5. Return Statement:**\n\nFinally, we return `ptr->next` to skip the temporary head and get the actual merged list.\n\n## Complexity Analysis\n\n- **Time Complexity:** `O(m+n)`, where `m` and `n` are the lengths of the two linked lists. We traverse each list once.\n\n- **Space Complexity:** `O(1)`. We use a constant amount of space, ignoring the space used by the input and output linked lists.\n\n## Dry Run Example\n\nLet’s perform a dry run of the function with the following input:\n\n**Input:**\n\n`list1`: `1 → 2 → 4`\n\n`list2`: `1 → 3 → 4`\n\n## Iteration Breakdown\n\n**1. Initialization:**\n\n- `ptr` and `temp` point to a new temporary node.\n\n**2. First Iteration:**\n\nCompare `1` (from `list1`) and `1` (from `list2`). Both are equal.\nAppend `1` from `list2` to the merged list.\n\nMove `temp` to point to this new node, and advance `list2` to `3`.\n\n**3. Second Iteration:**\n\nCompare `1` (from `list1`) and `3` (from `list2`).\n\nAppend `1` from `list1` to the merged list.\n\nMove `temp` to this new node, and advance `list1` to `2`.\n\n**4. Third Iteration:**\n\nCompare `2` (from `list1`) and `3` (from `list2`).\n\nAppend `2` from `list1` to the merged list.\n\nMove `temp` to this new node, and advance `list1` to `4`.\n\n**5. Fourth Iteration:**\n\nCompare `4` (from `list1`) and `3` (from `list2`).\n\nAppend `3` from `list2` to the merged list.\n\nMove `temp` to this new node, and advance `list2` to `4`.\n\n**6. Fifth Iteration:**\n\nCompare `4` (from `list1`) and `4` (from `list2`).\n\nAppend `4` from `list2` to the merged list.\n\nMove `temp` to this new node, and advance `list2` to `NULL`.\n\n**7. Remaining Nodes:**\n\nNow `list2` is `NULL`. We append the remaining node `4` from `list1` to the merged list.\n\n## Final Output\n\nThe final output is the merged linked list:\n\n`1 → 1 → 2 → 3 → 4 → 4`\n\n## Conclusion\n\nIn this post, we examined how to merge two sorted linked lists into a single sorted linked list. We discussed the code implementation, analyzed its complexity, and performed a dry run to illustrate the algorithm's operation. This merging technique is efficient and straightforward, making it a valuable approach in various linked list problems."
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k.",
      "slug": "remove-duplicates-from-sorted-array",
      "date": "30-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727709593/remove-duplicates-from-sorted-array_dkxtgj.png",
      "content": "## Remove Duplicates from Sorted Array\n\nIn this post, we will explore an efficient way to remove duplicates from a sorted array. This problem is frequently encountered in coding interviews and tests your ability to manipulate arrays effectively.\n\n## Problem Description\n\nGiven a sorted array of integers, the task is to remove the duplicates in-place such that each unique element appears only once. The function should return the new length of the array after removing duplicates. The relative order of the elements should be preserved.\n\n## Example\n\nConsider the following sorted array:\n\nInput: `nums = [1, 1, 2]`\n\nOutput: `2` (The first two elements of `nums` will now contain `1` and `2.`)\n\n## Code Implementation\n\nHere’s the C++ code that implements this logic:\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int count = 1; // Count of unique elements\n        int index = 1; // Index for placing the next unique element\n\n        // Traverse the sorted array\n        for (int i = 1; i < nums.size(); i++) {\n            // If the current element is not equal to the previous one\n            if (nums[i] != nums[i - 1]) {\n                nums[index++] = nums[i]; // Place it in the unique position\n                count++; // Increment the count of unique elements\n            }\n        }\n        return index; // Return the length of the unique elements\n    }\n};\n```\n\n## Code Explanation\n\n**1. Initialization:**\n\nWe start by initializing two variables: `count`, which tracks the number of unique elements (initialized to `1`, assuming the first element is unique), and `index`, which is set to `1`, indicating the position to place the next unique element.\n\n**2. Loop Through the Array:**\n\nWe loop through the array starting from the second element (index `1`). For each element, we compare it with the previous element.\n\n**3. Check for Duplicates:**\n\nIf the current element (`nums[i]`) is not equal to the previous element (`nums[i - 1]`), it indicates that we have found a unique element.\n\nWe place this unique element at the `index` position and increment both `index` and `count`.\n\n**4. Return Statement:**\n\nAfter the loop, we return `index`, which represents the new length of the array after removing duplicates.\n\n## Complexity Analysis\n\n- **Time Complexity:** `O(n)`, where `n` is the number of elements in the input array. We traverse the array only once.\n\n- **Space Complexity:** `O(1)`. We modify the input array in-place, using a constant amount of extra space for variables.\n\n## Dry Run Example\n\nLet’s perform a dry run of the function with the following input:\n\nInput: `nums = [0, 0, 1, 1, 2, 2, 3, 4, 4]`\n\n## Iteration Breakdown\n\n**1. Initialization:**\n\n`count = 1`\n\n`index = 1`\n\n**2. First Iteration (i = 1):**\n\nCompare `nums[1] (0)` with `nums[0] (0)`: they are equal.\n\nNo change, move to the next iteration.\n\n**3. Second Iteration (i = 2):**\n\nCompare `nums[2] (1)` with `nums[1] (0)`: they are different.\n\nPlace `1` at index `1`: `nums[1] = 1`.\n\nIncrement `index` to `2` and `count` to `2`.\n\n**4. Third Iteration (i = 3):**\n\nCompare `nums[3] (1)` with `nums[2] (1)`: they are equal.\n\nNo change, move to the next iteration.\n\n**5. Fourth Iteration (i = 4):**\n\nCompare `nums[4] (2)` with `nums[3] (1)`: they are different.\n\nPlace `2` at index `2`: `nums[2] = 2`.\n\nIncrement `index` to `3` and `count` to `3`.\n\n**6. Fifth Iteration (i = 5):**\n\nCompare `nums[5] (2)` with `nums[4] (2)`: they are equal.\n\nNo change, move to the next iteration.\n\n**7. Sixth Iteration (i = 6):**\n\nCompare `nums[6] (3)` with `nums[5] (2)`: they are different.\n\nPlace `3` at index `3`: `nums[3] = 3`.\n\nIncrement `index` to `4` and `count` to `4`.\n\n**8. Seventh Iteration (i = 7):**\n\nCompare `nums[7] (4)` with `nums[6] (3)`: they are different.\n\nPlace `4` at index `4`: `nums[4] = 4`.\n\nIncrement `index` to `5` and `count` to `5`.\n\n**9. Eighth Iteration (i = 8):**\n\nCompare `nums[8] (4)` with `nums[7] (4)`: they are equal.\n\nNo change, move to the next iteration.\n\n## Final Output\n\nThe final output is the new length of the array, which is `5`. The modified array contains unique elements at the beginning:\n\n`nums = [0, 1, 2, 3, 4, ...]` (Only the first `5` elements matter)\n\n## Conclusion\n\nIn this post, we explored how to remove duplicates from a sorted array efficiently. We discussed the code implementation, analyzed its complexity, and performed a dry run to illustrate the algorithm's operation. This technique is valuable for many array manipulation problems and is essential to understand for coding interviews."
    },
    {
      "title": "Remove Element",
      "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k.",
      "slug": "remove-element",
      "date": "30-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727709861/remove-element_w5msec.png",
      "content": "## Problem Statement\n\nThe removeElement problem is a common coding task where we are given an array `nums` and a value `val`. The goal is to remove all occurrences of `val` from `nums` in-place, meaning we should not use extra space for another array. The relative order of elements can be changed. It is also required to return the new length of the modified array after the removal.\n\n## For example:\n\n**Input:**\n\n`nums = [3,2,2,3]`\n\n`val = 3`\n\n**Output:**\n\nLength of modified array: `2`\n\nModified array: `[2, 2]`\n\n## Approach\n\nThis problem can be solved using the two-pointer technique. We traverse the array and shift non-`val` elements to the front of the array.\n\n## Algorithm Explanation\n\nWe initialize a variable `index` to `0`. This pointer keeps track of the position where the next valid element (i.e., not equal to `val`) will be placed.\n\nWe iterate through the array `nums` using a for loop. For each element, we check if it is equal to `val`.\n\nIf the current element is not equal to `val`, we assign it to the position `index` and increment `index` to prepare for the next valid element.\n\nAfter completing the loop, the value of `index` represents the new length of the modified array, as all elements before this index are the ones not equal to `val`.\n\n## C++ Code Implementation\n\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val){\n        int index = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != val) {\n                nums[index++] = nums[i];\n            }\n        }\n        return index;\n    }\n};\n```\n\n## Dry Run\n\nLet's go through a dry run of the algorithm with an example:\n\n**Input:**\n\n`nums = [3, 2, 2, 3]`, `val = 3`\n\n**Initialization**\n\n`index = 0.`\n\n**Iteration 1:**\n\n`i = 0`, `nums[0] = 3`, which is equal to `val`. No assignment is made.\n\n**Iteration 2:**\n\n`i = 1`, `nums[1] = 2`, which is not equal to `val`. Assign `nums[0] = nums[1]`, update `index = 1`.\n\n**Iteration 3:**\n\n`i = 2`, `nums[2] = 2`, which is not equal to `val`. Assign `nums[1] = nums[2]`, update `index = 2`.\n\n**Iteration 4:**\n\n`i = 3`, `nums[3] = 3`, which is equal to `val`. No assignment is made.\n\nAt the end of the loop, the value of `index` is `2`, and `nums` has been modified to `[2, 2]` with a new length of `2`.\n\n## Complexity Analysis\n\n- **Time Complexity:** `O(n)`, where `n` is the size of the array. We traverse the entire array once.\n\n- **Space Complexity:** `O(1)`, since we are modifying the array in-place without using extra space.\n\n## Conclusion\n\nThe solution to the removeElement problem is efficient, as it operates in linear time and constant space. By using a simple two-pointer approach, we can easily remove all occurrences of a given value from an array while maintaining the relative order of the remaining elements.\n\nThis technique is quite versatile and can be applied to other similar problems involving in-place modifications of arrays."
    },
    {
      "title": "Remove Nth Node From End of List",
      "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
      "slug": "remove-nth-node-from-end-of-list",
      "date": "28-09-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1727708588/remove-nth-node-from-end-of-list_ieestt.png",
      "content": "## Remove N-th Node From End of List - C++ Solution\n\n## Problem Statement\n\nIn this problem, we are given a singly-linked list and an integer `n`. The goal is to remove the N-th node from the end of the list and return the head of the modified linked list.\n\n## For example:\n\n**Input:**\n\n`head = [1,2,3,4,5]`\n\n`n = 2`\n\n**Output:**\n\n`head = [1,2,3,5]`\n\nThis means the second node from the end (node with value 4) should be removed.\n\n## Approach\n\nTo solve this problem, we can use a two-pointer technique to find the node that is n nodes from the end in one pass. The idea is to maintain two pointers that are separated by n nodes and traverse the list. When the first pointer reaches the end, the second pointer will be at the node just before the target node.\n\n## Algorithm Explanation\n\n1. **Edge Case Handling:**\n\nIf the linked list contains only one node, we can delete the head and return NULL.\n\n2. **Initialize Two Pointers:**\n\nWe initialize two pointers, `ptr1` and `ptr2`, both pointing to the head of the linked list.\n\n3. **Move the First Pointer ptr1:**\n\nMove the first pointer `ptr1` forward by n steps. This ensures that the second pointer `ptr2` is n steps behind `ptr1`.\n\n4. **Handle the Case Where the N-th Node is the Head:**\n\nIf `ptr1` becomes NULL after moving n steps, it means the N-th node from the end is the head. In this case, we need to delete the head and return the new head, which will be the next node in the list.\n\n5. **Move Both Pointers:**\n\nContinue moving both `ptr1` and `ptr2` one step at a time until `ptr1` reaches the last node. Now, `ptr2` will point to the node just before the N-th node from the end.\n\n6. **Delete the N-th Node:**\n\nRemove the target node by updating `ptr2->next` to skip over the N-th node. Then, free the memory for the deleted node.\n\n7. **Return the Head:**\n\nFinally, return the head of the modified linked list.\n\n## C++ Code Implementation\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        // If the linked list has only one node, simply delete it and return NULL\n        if (head->next == NULL) {\n            delete(head);\n            return NULL;\n        }\n\n        // Initialize two pointers, ptr1 and ptr2, both starting from the head\n        ListNode* ptr1 = head;\n        ListNode* ptr2 = head;\n\n        // Move ptr1 n steps ahead so that ptr1 and ptr2 maintain a gap of n nodes\n        while (n > 0) {\n            ptr1 = ptr1->next;\n            n--;\n        }\n\n        // If ptr1 reaches NULL, this means we need to remove the head\n        if (ptr1 == NULL) {\n            ListNode* newHead = head->next; // New head is the second node\n            delete(head); // Delete the original head\n            return newHead;\n        }\n\n        // Move both pointers one step at a time until ptr1 reaches the last node\n        while (ptr1->next != NULL) {\n            ptr1 = ptr1->next;\n            ptr2 = ptr2->next;\n        }\n\n        // Now ptr2 is just before the node to be deleted. Remove the nth node.\n        ListNode* temp = ptr2->next;\n        ptr2->next = temp->next; // Bypass the node to be deleted\n        delete(temp); // Delete the nth node from the end\n\n        // Return the modified head of the linked list\n        return head;\n    }\n};\n```\n\n## Dry Run\n\nLet's take an example to better understand how the algorithm works.\n\n**Input:**\n\n`head = [1, 2, 3, 4, 5]`, `n = 2`\n\n**Step-by-Step Execution:**\n\n**Initialize**\n\n`ptr1 = head`, `ptr2 = head.`\n\n**Move ptr1 forward by 2 steps:**\n\nAfter 1st step: `ptr1 = 2`\n\nAfter 2nd step: `ptr1 = 3`\n\n**Now, move both pointers one step at a time:**\n\n`ptr1 = 4`, `ptr2 = 1`\n\n`ptr1 = 5`, `ptr2 = 2`\n\n`ptr1 = NULL`, `ptr2 = 3` (stops here)\n\n**Now, ptr2->next is the node to be deleted (node with value 4).**\n\nUpdate `ptr2->next` to skip the node with value 4, so the new list becomes:\n`head = [1, 2, 3, 5].`\n\n**Return the modified head.**\n\n## Complexity Analysis\n\n- **Time Complexity:** `O(L)`, where `L` is the length of the linked list. We traverse the linked list once.\n\n- **Space Complexity:** `O(1)`, since we are using only constant extra space (for the two pointers).\n\n## Conclusion\n\nThe above solution efficiently removes the N-th node from the end of a linked list in just one pass. The use of two pointers ensures that we can find and remove the node without needing extra space or multiple iterations. This technique is also versatile and can be applied to various problems involving linked lists."
    },
    {
      "title": "Removing Stars from a String",
      "description": "Given a string s with stars '*', remove the closest non-star character to the left of each '*'.",
      "slug": "removing-stars-from-a-string",
      "date": "03-11-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1730620855/removing-stars-from-a-string_k4zhiu.png",
      "content": "## Problem: Removing Stars from a String (LeetCode #2390)\n\nThe \"Removing Stars from a String\" problem (LeetCode #2390) requires removing stars `'*'` in a given string `s` by deleting the closest non-star character to the left of each `'*'`. The solution needs to ensure the final string is unique and contains no stars.\n\n## Problem Statement\n\nGiven a string `s`, return the resulting string after performing the following operations:\n1. For each `'*'` in `s`, remove it along with the closest non-star character to its left.\n2. Continue until all stars have been removed.\n\n**Example:**\n- **Input:** `s = \"leet**cod*e\"`\n- **Output:** `\"lecoe\"`\n  \nExplanation:\n1. Remove the 't' closest to the first `'*'`, resulting in `\"lee*cod*e\"`.\n2. Remove the 'e' closest to the second `'*'`, resulting in `\"lecod*e\"`.\n3. Remove the 'd' closest to the last `'*'`, resulting in `\"lecoe\"`.\n\n**Constraints:**\n- (1 <= s.length <= 10^5)\n- `s` consists of lowercase English letters and stars `'*'`.\n- Each `'*'` will always have a non-star character to its left to remove.\n\n## Solution Overview\n\nTo solve this efficiently, we can use a stack to manage the characters in the string as we process it. This approach allows us to remove characters in O(n) time, where n is the length of the string.\n\n## Approach\n\n**1. Use a stack for character storage:** We iterate through each character in `s`. For every `'*'` encountered, we pop the top character from the stack (effectively removing the closest non-star character to the left). For other characters, we simply push them onto the stack.\n\n**2. Construct the result string:** Once the traversal is complete, the stack will contain the characters of the final string in the correct order. Convert the stack to a string and return it.\n\n### Code Explanation\n\n```cpp\nclass Solution {\npublic:\n    string removeStars(string s) {\n        stack<char> charStack; // Stack to store the characters\n        \n        for(char ch : s) {\n            if(ch == '*') {\n                if(!charStack.empty()) {\n                    charStack.pop(); // Remove the closest non-star character\n                }\n            } else {\n                charStack.push(ch); // Add the character to the stack\n            }\n        }\n        \n        // Construct the result string from the stack\n        string result = \"\";\n        while(!charStack.empty()) {\n            result += charStack.top();\n            charStack.pop();\n        }\n        \n        // The stack gives us characters in reverse order, so reverse the result\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n\n## Dry Run\n\n**Example:** `s = \"erase*****\"`\n\n- **Initial Stack:** `[]`\n- **Step-by-Step Process:**\n  - Add 'e': `['e']`\n  - Add 'r': `['e', 'r']`\n  - Add 'a': `['e', 'r', 'a']`\n  - Add 's': `['e', 'r', 'a', 's']`\n  - Add 'e': `['e', 'r', 'a', 's', 'e']`\n  - For each `'*'`, pop the stack until it becomes empty.\n  \n- **Final Result:** `\"\"`\n\n## Complexity Analysis\n\n- **Time Complexity:** O(n), where n is the length of the string `s`. Each character is processed once.\n- **Space Complexity:** O(n), for the stack used to build the result.\n\n## Conclusion\n\nThis solution efficiently removes stars and their corresponding characters from the string using a stack. It leverages stack operations to ensure that the removal process is performed in a single pass, making it well-suited for larger input sizes."
    },
    {
      "title": "Maximum Number of Vowels in a Substring of Given Length",
      "description": "Given a string s and an integer k, return the maximum number of vowels in any substring of length k.",
      "slug": "maximum-number-of-vowels-in-a-substring-of-given-length",
      "date": "03-11-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1730621909/maximum-number-of-vowels-in-substring_eykjyd.png",
      "content": "## Problem: Maximum Number of Vowels in a Substring of Given Length (LeetCode #1456)\n\nGiven a string `s` and an integer `k`, this problem asks us to find the maximum number of vowel letters in any substring of `s` with length `k`. \n\nVowel letters in English are 'a', 'e', 'i', 'o', and 'u'.\n\n### Problem Statement\n\nGiven a string `s`, return the maximum number of vowels in any substring of length `k`.\n\n**Examples:**\n- **Input:** `s = \"abciiidef\"`, `k = 3`  \n  **Output:** `3`  \n  **Explanation:** The substring \"iii\" contains 3 vowels.\n\n- **Input:** `s = \"aeiou\"`, `k = 2`  \n  **Output:** `2`  \n  **Explanation:** Any substring of length 2 contains 2 vowels.\n\n- **Input:** `s = \"leetcode\"`, `k = 3`  \n  **Output:** `2`  \n  **Explanation:** \"lee\", \"eet\", and \"ode\" contain 2 vowels.\n\n**Constraints:**\n- (1 <= s.length <= 10^5)\n- `s` consists of lowercase English letters.\n- (1 <= k <= s.length)\n\n## Solution Overview\n\nWe can solve this problem by using a sliding window technique to count vowels over each substring of length `k`. Using this approach, we efficiently count vowels in one pass of `s`.\n\n### Approach\n\n1. **Sliding Window:** Start by counting vowels in the first `k` characters of `s`.\n2. **Window Slide:** For each subsequent character in `s`, slide the window to the right by one character:\n   - Subtract the count if the outgoing character is a vowel.\n   - Add to the count if the incoming character is a vowel.\n3. **Track Maximum:** Update the maximum vowel count encountered during this process.\n\n### Code Explanation\n\n```cpp\nclass Solution {\npublic:\n    bool isVowel(char ch) {\n        ch = tolower(ch);\n        return (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u');\n    }\n\n    int maxVowels(string s, int k) {\n        int n = s.length();\n        int st = 0, end = k - 1;\n        int currVowelCount = 0;\n        int maxVowelCount = INT_MIN;\n\n        // Initial count of vowels in the first k-length substring\n        for (int i = 0; i < k; i++) {\n            if (isVowel(s[i])) currVowelCount++;\n        }\n        maxVowelCount = max(maxVowelCount, currVowelCount);\n\n        // Sliding window over the rest of the string\n        for (int i = 0; i < n - k; i++) {\n            if (isVowel(s[st])) {\n                currVowelCount--;\n            }\n            st++;\n            end++;\n            if (isVowel(s[end])) {\n                currVowelCount++;\n            }\n            maxVowelCount = max(maxVowelCount, currVowelCount);\n        }\n        return maxVowelCount;\n    }\n};\n```\n\n## Dry Run\n\n**Example:** `s = \"abciiidef\"`, `k = 3`\n\n1. **Initial Count:** \"abc\" has 1 vowel (`a`).\n2. **Window Slide:** Slide the window one character at a time.\n   - \"bci\" has 1 vowel.\n   - \"cii\" has 2 vowels.\n   - \"iii\" has 3 vowels (maximum).\n   - Continue sliding with the rest, resulting in a maximum of 3 vowels.\n\n**Final Result:** `3`\n\n## Complexity Analysis\n\n- **Time Complexity:** O(n), where n is the length of `s`. We iterate over each character once.\n- **Space Complexity:** O(1), as we use a constant amount of extra space.\n\n## Conclusion\n\nThis solution efficiently finds the maximum number of vowels in any substring of length `k` by using a sliding window, enabling us to handle larger strings effectively."
    },
    {
      "title": "Delete the Middle Node of a Linked List",
      "description": "You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.",
      "slug": "delete-the-middle-node-of-a-linked-list",
      "date": "03-11-24",
      "author": "Manishkumar Gupta",
      "image": "https://res.cloudinary.com/dffoynel3/image/upload/v1730622621/delete-middle-node-of-a-linked-list_lvhbfo.png",
      "content": "# 2095. Delete the Middle Node of a Linked List\n\n**Status:** Solved  \n**Difficulty:** Medium  \n**Topics:** Linked List  \n\n## Problem Statement\n\nYou are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\n\nThe middle node of a linked list of size `n` is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.\n\nFor n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\n\n### Examples\n\n**Example 1:**\n\n**Input:** head = [1,3,4,7,1,2,6]  \n**Output:** [1,3,4,1,2,6]  \n**Explanation:** Node 3 with value 7 is the middle node.\n\n**Example 2:**\n\n**Input:** head = [1,2,3,4]  \n**Output:** [1,2,4]  \n**Explanation:** Node 2 with value 3 is the middle node.\n\n**Example 3:**\n\n**Input:** head = [2,1]  \n**Output:** [2]  \n**Explanation:** Node 1 with value 1 is the middle node.\n\n### Constraints\n\n- The number of nodes in the list is in the range [1, 10^5].  \n- 1 <= Node.val <= 10^5\n\n## Code Implementation\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteMiddle(ListNode* head) {\n\n        if(!head || !head->next) return NULL;\n\n        ListNode* fast_ptr=head;\n        ListNode* slow_ptr=head;\n        ListNode* slow_prev=NULL;\n\n        while(fast_ptr && fast_ptr->next){\n            slow_prev=slow_ptr;\n            fast_ptr=fast_ptr->next->next;\n            slow_ptr=slow_ptr->next;\n        }\n\n        slow_prev->next=slow_ptr->next;\n        return head;\n    }\n};\n```\n\n## Dry Run\n\n**Example:** `head = [1,3,4,7,1,2,6]`\n\n- **Initial List:** `1 -> 3 -> 4 -> 7 -> 1 -> 2 -> 6`\n- **Fast Pointer:** Moves two steps at a time.\n- **Slow Pointer:** Moves one step at a time.\n- **Middle Node:** Slow pointer reaches the middle node (7).\n\n**Steps:**\n\n1. First iteration: `slow_ptr = 3`, `fast_ptr = 4`\n2. Second iteration: `slow_ptr = 4`, `fast_ptr = 7`\n3. Third iteration: `slow_ptr = 7`, `fast_ptr = 1`\n4. Fourth iteration: `slow_ptr = 1`, `fast_ptr = NULL`\n\n- The middle node (value 7) is removed.\n- **Final List:** `1 -> 3 -> 4 -> 1 -> 2 -> 6`\n\n## Conclusion\n\nThis solution efficiently removes the middle node from a linked list using the fast and slow pointer technique, which ensures optimal time complexity."
    } 
  ]
  